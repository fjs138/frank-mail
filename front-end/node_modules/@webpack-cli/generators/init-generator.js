"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const logSymbols = require("log-symbols");
const Generator = require("yeoman-generator");
const path = require("path");
const package_manager_1 = require("@webpack-cli/utils/package-manager");
const webpack_scaffold_1 = require("@webpack-cli/webpack-scaffold");
const utils_1 = require("./utils");
/**
 *
 * Generator for initializing a webpack config
 *
 * @class 	InitGenerator
 * @extends Generator
 * @returns {Void} After execution, transforms are triggered
 *
 */
class InitGenerator extends Generator {
    constructor(args, opts) {
        super(args, opts);
        this.usingDefaults = true;
        this.autoGenerateConfig = opts.autoSetDefaults ? true : false;
        this.dependencies = ["webpack", "webpack-cli", "babel-plugin-syntax-dynamic-import"];
        this.configuration = {
            config: {
                configName: "config",
                topScope: [],
                webpackOptions: {
                    mode: "'production'",
                    entry: undefined,
                    output: undefined,
                    plugins: [],
                    module: {
                        rules: []
                    }
                }
            }
        };
        // add splitChunks options for transparency
        // defaults coming from: https://webpack.js.org/plugins/split-chunks-plugin/#optimization-splitchunks
        this.configuration.config.topScope.push("const path = require('path');", "const webpack = require('webpack');", "\n", utils_1.tooltip.splitChunks());
        this.configuration.config.webpackOptions.plugins.push("new webpack.ProgressPlugin()");
    }
    prompting() {
        return __awaiter(this, void 0, void 0, function* () {
            const done = this.async();
            const self = this;
            process.stdout.write(`\n${logSymbols.info}${chalk_1.default.blue(" INFO ")} ` +
                `For more information and a detailed description of each question, have a look at: ` +
                `${chalk_1.default.bold.green("https://github.com/webpack/webpack-cli/blob/master/INIT.md")}\n`);
            process.stdout.write(`${logSymbols.info}${chalk_1.default.blue(" INFO ")} ` +
                `Alternatively, run "webpack(-cli) --help" for usage info\n\n`);
            const { multiEntries } = yield webpack_scaffold_1.Confirm(self, "multiEntries", "Will your application have multiple bundles?", false, this.autoGenerateConfig);
            // TODO string | object
            const entryOption = yield utils_1.entryQuestions(self, multiEntries, this.autoGenerateConfig);
            if (typeof entryOption === "string") {
                if (entryOption.length === 0) {
                    this.usingDefaults = true;
                }
                else if (entryOption.length > 0) {
                    this.usingDefaults = entryOption && entryOption === "'./src/index.js'";
                    if (!this.usingDefaults) {
                        this.configuration.config.webpackOptions.entry = `${entryOption}`;
                    }
                }
            }
            else if (typeof entryOption === "object") {
                this.configuration.config.webpackOptions.entry = entryOption;
            }
            const { outputDir } = yield webpack_scaffold_1.Input(self, "outputDir", "In which folder do you want to store your generated bundles?", "'dist'", this.autoGenerateConfig);
            this.usingDefaults = !outputDir || outputDir === "'dist'";
            if (!this.usingDefaults) {
                this.configuration.config.webpackOptions.output = {
                    chunkFilename: "'[name].[chunkhash].js'",
                    filename: "'[name].[chunkhash].js'"
                };
            }
            const { langType } = yield webpack_scaffold_1.List(self, "langType", "Will you use one of the below JS solutions?", ["No", utils_1.LangType.ES6, utils_1.LangType.Typescript], "No", this.autoGenerateConfig);
            utils_1.langQuestionHandler(this, langType);
            this.langType = langType;
            if (this.langType !== "No") {
                this.usingDefaults = false;
            }
            const { stylingType } = yield webpack_scaffold_1.List(self, "stylingType", "Will you use one of the below CSS solutions?", ["No", utils_1.StylingType.CSS, utils_1.StylingType.SASS, utils_1.StylingType.LESS, utils_1.StylingType.PostCSS], "No", this.autoGenerateConfig);
            if (this.langType === "No") {
                this.usingDefaults = true;
            }
            const { ExtractUseProps, regExpForStyles } = utils_1.styleQuestionHandler(self, stylingType);
            if (stylingType !== "No") {
                this.usingDefaults = false;
            }
            // Ask if the user wants to use extractPlugin
            const { useExtractPlugin } = yield webpack_scaffold_1.Input(self, "useExtractPlugin", "If you want to bundle your CSS files, what will you name the bundle? (press enter to skip)", "main", this.autoGenerateConfig);
            if (regExpForStyles) {
                const cssBundleName = useExtractPlugin;
                this.dependencies.push("mini-css-extract-plugin");
                this.configuration.config.topScope.push(utils_1.tooltip.cssPlugin(), "const MiniCssExtractPlugin = require('mini-css-extract-plugin');", "\n");
                if (cssBundleName.length !== 0) {
                    this.configuration.config.webpackOptions.plugins.push(
                    // TODO: use [contenthash] after it is supported
                    `new MiniCssExtractPlugin({ filename:'${cssBundleName}.[chunkhash].css' })`);
                }
                else {
                    this.configuration.config.webpackOptions.plugins.push("new MiniCssExtractPlugin({ filename:'style.css' })");
                }
                ExtractUseProps.unshift({
                    loader: "MiniCssExtractPlugin.loader"
                });
                this.configuration.config.webpackOptions.module.rules.push({
                    test: regExpForStyles,
                    use: ExtractUseProps
                });
            }
            if (this.usingDefaults) {
                // Html webpack Plugin
                this.dependencies.push("html-webpack-plugin");
                const htmlWebpackDependency = "html-webpack-plugin";
                const htmlwebpackPlugin = utils_1.generatePluginName(htmlWebpackDependency);
                this.configuration.config.topScope.push(`const ${htmlwebpackPlugin} = require('${htmlWebpackDependency}')`, "\n", utils_1.tooltip.html());
                this.configuration.config.webpackOptions.plugins.push(`new ${htmlwebpackPlugin}({
					template: 'index.html'
				})`);
                // webpack Dev Server
                this.dependencies.push("webpack-dev-server");
                this.configuration.config.webpackOptions.devServer = {
                    open: true
                };
            }
            // TerserPlugin
            this.dependencies.push("terser-webpack-plugin");
            this.configuration.config.topScope.push(utils_1.tooltip.terser(), "const TerserPlugin = require('terser-webpack-plugin');", "\n");
            // PWA + offline support
            this.configuration.config.topScope.push("const workboxPlugin = require('workbox-webpack-plugin');", "\n");
            this.dependencies.push("workbox-webpack-plugin");
            this.configuration.config.webpackOptions.plugins.push(`new workboxPlugin.GenerateSW({
			swDest: 'sw.js',
			clientsClaim: true,
			skipWaiting: false,
		})`);
            // Chunksplitting
            this.configuration.config.webpackOptions.optimization = utils_1.getDefaultOptimization(this.usingDefaults);
            this.configuration.config.webpackOptions.mode = this.usingDefaults ? "'production'" : "'development'";
            done();
        });
    }
    installPlugins() {
        const packager = package_manager_1.getPackageManager();
        const opts = packager === "yarn" ? { dev: true } : { "save-dev": true };
        this.scheduleInstallTask(packager, this.dependencies, opts);
    }
    writing() {
        this.configuration.usingDefaults = this.usingDefaults;
        this.config.set("configuration", this.configuration);
        if (this.langType === "ES6") {
            this.fs.copyTpl(path.resolve(__dirname, "./templates/.babelrc"), this.destinationPath(".babelrc"), {});
        }
        const packageJsonTemplatePath = "./templates/package.json.js";
        this.fs.extendJSON(this.destinationPath("package.json"), require(packageJsonTemplatePath)(this.usingDefaults));
        const generateEntryFile = (entryPath, name) => {
            entryPath = entryPath.replace(/'/g, "");
            this.fs.copyTpl(path.resolve(__dirname, "./templates/index.js"), this.destinationPath(entryPath), { name });
        };
        // Generate entry file/files
        const entry = this.configuration.config.webpackOptions.entry || "./src/index.js";
        if (typeof entry === "string") {
            generateEntryFile(entry, "your main file!");
        }
        else if (typeof entry === "object") {
            Object.keys(entry).forEach((name) => generateEntryFile(entry[name], `${name} main file!`));
        }
        // Generate README
        this.fs.copyTpl(path.resolve(__dirname, "./templates/README.md"), this.destinationPath("README.md"), {});
        // Generate HTML template file
        if (this.usingDefaults) {
            this.fs.copyTpl(path.resolve(__dirname, "./templates/template.html"), this.destinationPath("index.html"), {});
        }
        // Genrate tsconfig
        if (this.langType === utils_1.LangType.Typescript) {
            const tsConfigTemplatePath = "./templates/tsconfig.json.js";
            this.fs.extendJSON(this.destinationPath("tsconfig.json"), require(tsConfigTemplatePath));
        }
    }
}
exports.default = InitGenerator;
//# sourceMappingURL=init-generator.js.map