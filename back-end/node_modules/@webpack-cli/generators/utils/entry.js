"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_scaffold_1 = require("@webpack-cli/webpack-scaffold");
const validate_1 = require("./validate");
/**
 *
 * Prompts for entry points, either if it has multiple or one entry
 *
 * @param	{Object} self 	- A variable holding the instance of the prompting
 * @param	{Object} answer - Previous answer from asking if the user wants single or multiple entries
 * @returns	{Object} An Object that holds the answers given by the user, later used to scaffold
 */
function entry(self, multiEntries, autoGenerateDefaults = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const webpackEntryPoint = {};
        // TODO: refactoring to async/await
        function forEachPromise(entries, fn) {
            return __awaiter(this, void 0, void 0, function* () {
                return entries.reduce((promise, prop) => {
                    const trimmedProp = prop.trim();
                    return promise.then((n) => {
                        if (n) {
                            Object.keys(n).forEach((val) => {
                                if (n[val].charAt(0) !== "(" &&
                                    n[val].charAt(0) !== "[" &&
                                    !n[val].includes("function") &&
                                    !n[val].includes("path") &&
                                    !n[val].includes("process")) {
                                    n[val] = `\'./${n[val].replace(/"|'/g, "").concat(".js")}\'`;
                                }
                                webpackEntryPoint[val] = n[val];
                            });
                        }
                        else {
                            n = {};
                        }
                        return fn(trimmedProp);
                    });
                }, Promise.resolve());
            });
        }
        if (multiEntries) {
            const multipleEntriesAnswer = yield webpack_scaffold_1.InputValidate(self, "multipleEntries", "What do you want to name your bundles? (separated by comma)", validate_1.default, "pageOne, pageTwo", autoGenerateDefaults);
            const entryIdentifiers = multipleEntriesAnswer.multipleEntries.split(",");
            const entryPropAnswer = yield forEachPromise(entryIdentifiers, (entryProp) => {
                return webpack_scaffold_1.InputValidate(self, `${entryProp}`, `What is the location of "${entryProp}"?`, validate_1.default, `src/${entryProp}`, autoGenerateDefaults);
            });
            const remainingEntryPropKeys = Object.keys(entryPropAnswer);
            if (remainingEntryPropKeys.length > 0) {
                remainingEntryPropKeys.forEach((val) => {
                    if (entryPropAnswer[val].charAt(0) !== "(" &&
                        entryPropAnswer[val].charAt(0) !== "[" &&
                        !entryPropAnswer[val].includes("function") &&
                        !entryPropAnswer[val].includes("path") &&
                        !entryPropAnswer[val].includes("process")) {
                        entryPropAnswer[val] = `\'./${entryPropAnswer[val].replace(/"|'/g, "").concat(".js")}\'`;
                    }
                    webpackEntryPoint[val] = entryPropAnswer[val];
                });
            }
            return webpackEntryPoint;
        }
        const singleEntryResult = yield webpack_scaffold_1.Input(self, "singularEntry", "Which will be your application entry point?", "src/index", autoGenerateDefaults);
        let { singularEntry } = singleEntryResult;
        singularEntry = `\'./${singularEntry.replace(/"|'/g, "").concat(".js")}\'`;
        return singularEntry;
    });
}
exports.default = entry;
//# sourceMappingURL=entry.js.map